// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plan.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_plan_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_plan_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "schema.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_plan_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_plan_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_plan_2eproto;
namespace milvus {
namespace proto {
namespace plan {
class BinaryArithExpr;
class BinaryArithExprDefaultTypeInternal;
extern BinaryArithExprDefaultTypeInternal _BinaryArithExpr_default_instance_;
class BinaryLogicalExpr;
class BinaryLogicalExprDefaultTypeInternal;
extern BinaryLogicalExprDefaultTypeInternal _BinaryLogicalExpr_default_instance_;
class BinaryRangeExpr;
class BinaryRangeExprDefaultTypeInternal;
extern BinaryRangeExprDefaultTypeInternal _BinaryRangeExpr_default_instance_;
class CastExpr;
class CastExprDefaultTypeInternal;
extern CastExprDefaultTypeInternal _CastExpr_default_instance_;
class ColumnExpr;
class ColumnExprDefaultTypeInternal;
extern ColumnExprDefaultTypeInternal _ColumnExpr_default_instance_;
class ColumnInfo;
class ColumnInfoDefaultTypeInternal;
extern ColumnInfoDefaultTypeInternal _ColumnInfo_default_instance_;
class CompareExpr;
class CompareExprDefaultTypeInternal;
extern CompareExprDefaultTypeInternal _CompareExpr_default_instance_;
class Expr;
class ExprDefaultTypeInternal;
extern ExprDefaultTypeInternal _Expr_default_instance_;
class GenericValue;
class GenericValueDefaultTypeInternal;
extern GenericValueDefaultTypeInternal _GenericValue_default_instance_;
class PlanNode;
class PlanNodeDefaultTypeInternal;
extern PlanNodeDefaultTypeInternal _PlanNode_default_instance_;
class QueryInfo;
class QueryInfoDefaultTypeInternal;
extern QueryInfoDefaultTypeInternal _QueryInfo_default_instance_;
class TermExpr;
class TermExprDefaultTypeInternal;
extern TermExprDefaultTypeInternal _TermExpr_default_instance_;
class UnaryArithExpr;
class UnaryArithExprDefaultTypeInternal;
extern UnaryArithExprDefaultTypeInternal _UnaryArithExpr_default_instance_;
class UnaryLogicalExpr;
class UnaryLogicalExprDefaultTypeInternal;
extern UnaryLogicalExprDefaultTypeInternal _UnaryLogicalExpr_default_instance_;
class UnaryRangeExpr;
class UnaryRangeExprDefaultTypeInternal;
extern UnaryRangeExprDefaultTypeInternal _UnaryRangeExpr_default_instance_;
class ValueExpr;
class ValueExprDefaultTypeInternal;
extern ValueExprDefaultTypeInternal _ValueExpr_default_instance_;
class VectorANNS;
class VectorANNSDefaultTypeInternal;
extern VectorANNSDefaultTypeInternal _VectorANNS_default_instance_;
}  // namespace plan
}  // namespace proto
}  // namespace milvus
PROTOBUF_NAMESPACE_OPEN
template<> ::milvus::proto::plan::BinaryArithExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::BinaryArithExpr>(Arena*);
template<> ::milvus::proto::plan::BinaryLogicalExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::BinaryLogicalExpr>(Arena*);
template<> ::milvus::proto::plan::BinaryRangeExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::BinaryRangeExpr>(Arena*);
template<> ::milvus::proto::plan::CastExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::CastExpr>(Arena*);
template<> ::milvus::proto::plan::ColumnExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::ColumnExpr>(Arena*);
template<> ::milvus::proto::plan::ColumnInfo* Arena::CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(Arena*);
template<> ::milvus::proto::plan::CompareExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::CompareExpr>(Arena*);
template<> ::milvus::proto::plan::Expr* Arena::CreateMaybeMessage<::milvus::proto::plan::Expr>(Arena*);
template<> ::milvus::proto::plan::GenericValue* Arena::CreateMaybeMessage<::milvus::proto::plan::GenericValue>(Arena*);
template<> ::milvus::proto::plan::PlanNode* Arena::CreateMaybeMessage<::milvus::proto::plan::PlanNode>(Arena*);
template<> ::milvus::proto::plan::QueryInfo* Arena::CreateMaybeMessage<::milvus::proto::plan::QueryInfo>(Arena*);
template<> ::milvus::proto::plan::TermExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::TermExpr>(Arena*);
template<> ::milvus::proto::plan::UnaryArithExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::UnaryArithExpr>(Arena*);
template<> ::milvus::proto::plan::UnaryLogicalExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::UnaryLogicalExpr>(Arena*);
template<> ::milvus::proto::plan::UnaryRangeExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::UnaryRangeExpr>(Arena*);
template<> ::milvus::proto::plan::ValueExpr* Arena::CreateMaybeMessage<::milvus::proto::plan::ValueExpr>(Arena*);
template<> ::milvus::proto::plan::VectorANNS* Arena::CreateMaybeMessage<::milvus::proto::plan::VectorANNS>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace milvus {
namespace proto {
namespace plan {

enum UnaryLogicalOp : int {
  InvalidUnaryLogicalOp = 0,
  Not = 1,
  UnaryLogicalOp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UnaryLogicalOp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UnaryLogicalOp_IsValid(int value);
constexpr UnaryLogicalOp UnaryLogicalOp_MIN = InvalidUnaryLogicalOp;
constexpr UnaryLogicalOp UnaryLogicalOp_MAX = Not;
constexpr int UnaryLogicalOp_ARRAYSIZE = UnaryLogicalOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UnaryLogicalOp_descriptor();
template<typename T>
inline const std::string& UnaryLogicalOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UnaryLogicalOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UnaryLogicalOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UnaryLogicalOp_descriptor(), enum_t_value);
}
inline bool UnaryLogicalOp_Parse(
    const std::string& name, UnaryLogicalOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UnaryLogicalOp>(
    UnaryLogicalOp_descriptor(), name, value);
}
enum BinaryLogicalOp : int {
  InvalidBinaryLogicalOp = 0,
  LogicalAnd = 1,
  LogicalOr = 2,
  BinaryLogicalOp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BinaryLogicalOp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BinaryLogicalOp_IsValid(int value);
constexpr BinaryLogicalOp BinaryLogicalOp_MIN = InvalidBinaryLogicalOp;
constexpr BinaryLogicalOp BinaryLogicalOp_MAX = LogicalOr;
constexpr int BinaryLogicalOp_ARRAYSIZE = BinaryLogicalOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BinaryLogicalOp_descriptor();
template<typename T>
inline const std::string& BinaryLogicalOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BinaryLogicalOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BinaryLogicalOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BinaryLogicalOp_descriptor(), enum_t_value);
}
inline bool BinaryLogicalOp_Parse(
    const std::string& name, BinaryLogicalOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BinaryLogicalOp>(
    BinaryLogicalOp_descriptor(), name, value);
}
enum CompareOp : int {
  InvalidCompareOp = 0,
  GreaterThan = 1,
  GreaterEqual = 2,
  LessThan = 3,
  LessEqual = 4,
  Equal = 5,
  NotEqual = 6,
  CompareOp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CompareOp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CompareOp_IsValid(int value);
constexpr CompareOp CompareOp_MIN = InvalidCompareOp;
constexpr CompareOp CompareOp_MAX = NotEqual;
constexpr int CompareOp_ARRAYSIZE = CompareOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompareOp_descriptor();
template<typename T>
inline const std::string& CompareOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompareOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompareOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompareOp_descriptor(), enum_t_value);
}
inline bool CompareOp_Parse(
    const std::string& name, CompareOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompareOp>(
    CompareOp_descriptor(), name, value);
}
enum UnaryArithOp : int {
  InvalidUnaryArithOp = 0,
  Minus = 1,
  BitNot = 2,
  UnaryArithOp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  UnaryArithOp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool UnaryArithOp_IsValid(int value);
constexpr UnaryArithOp UnaryArithOp_MIN = InvalidUnaryArithOp;
constexpr UnaryArithOp UnaryArithOp_MAX = BitNot;
constexpr int UnaryArithOp_ARRAYSIZE = UnaryArithOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UnaryArithOp_descriptor();
template<typename T>
inline const std::string& UnaryArithOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UnaryArithOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UnaryArithOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UnaryArithOp_descriptor(), enum_t_value);
}
inline bool UnaryArithOp_Parse(
    const std::string& name, UnaryArithOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UnaryArithOp>(
    UnaryArithOp_descriptor(), name, value);
}
enum BinaryArithOp : int {
  InvalidBinaryArithOp = 0,
  Add = 1,
  Subtract = 2,
  Multiply = 3,
  Divide = 4,
  Modulo = 5,
  Power = 6,
  BitAnd = 7,
  BitOr = 8,
  BitXor = 9,
  ShiftLeft = 10,
  ShiftRight = 11,
  BinaryArithOp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BinaryArithOp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BinaryArithOp_IsValid(int value);
constexpr BinaryArithOp BinaryArithOp_MIN = InvalidBinaryArithOp;
constexpr BinaryArithOp BinaryArithOp_MAX = ShiftRight;
constexpr int BinaryArithOp_ARRAYSIZE = BinaryArithOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BinaryArithOp_descriptor();
template<typename T>
inline const std::string& BinaryArithOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BinaryArithOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BinaryArithOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BinaryArithOp_descriptor(), enum_t_value);
}
inline bool BinaryArithOp_Parse(
    const std::string& name, BinaryArithOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BinaryArithOp>(
    BinaryArithOp_descriptor(), name, value);
}
// ===================================================================

class GenericValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.GenericValue) */ {
 public:
  GenericValue();
  virtual ~GenericValue();

  GenericValue(const GenericValue& from);
  GenericValue(GenericValue&& from) noexcept
    : GenericValue() {
    *this = ::std::move(from);
  }

  inline GenericValue& operator=(const GenericValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericValue& operator=(GenericValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GenericValue& default_instance();

  enum ValCase {
    kBoolVal = 1,
    kInt64Val = 2,
    kFloatVal = 3,
    VAL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenericValue* internal_default_instance() {
    return reinterpret_cast<const GenericValue*>(
               &_GenericValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GenericValue& a, GenericValue& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenericValue* New() const final {
    return CreateMaybeMessage<GenericValue>(nullptr);
  }

  GenericValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenericValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenericValue& from);
  void MergeFrom(const GenericValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.GenericValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolValFieldNumber = 1,
    kInt64ValFieldNumber = 2,
    kFloatValFieldNumber = 3,
  };
  // bool bool_val = 1;
  private:
  bool has_bool_val() const;
  public:
  void clear_bool_val();
  bool bool_val() const;
  void set_bool_val(bool value);

  // int64 int64_val = 2;
  private:
  bool has_int64_val() const;
  public:
  void clear_int64_val();
  ::PROTOBUF_NAMESPACE_ID::int64 int64_val() const;
  void set_int64_val(::PROTOBUF_NAMESPACE_ID::int64 value);

  // double float_val = 3;
  private:
  bool has_float_val() const;
  public:
  void clear_float_val();
  double float_val() const;
  void set_float_val(double value);

  void clear_val();
  ValCase val_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.GenericValue)
 private:
  class _Internal;
  void set_has_bool_val();
  void set_has_int64_val();
  void set_has_float_val();

  inline bool has_val() const;
  inline void clear_has_val();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union ValUnion {
    ValUnion() {}
    bool bool_val_;
    ::PROTOBUF_NAMESPACE_ID::int64 int64_val_;
    double float_val_;
  } val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class QueryInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.QueryInfo) */ {
 public:
  QueryInfo();
  virtual ~QueryInfo();

  QueryInfo(const QueryInfo& from);
  QueryInfo(QueryInfo&& from) noexcept
    : QueryInfo() {
    *this = ::std::move(from);
  }

  inline QueryInfo& operator=(const QueryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryInfo& operator=(QueryInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QueryInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryInfo* internal_default_instance() {
    return reinterpret_cast<const QueryInfo*>(
               &_QueryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(QueryInfo& a, QueryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryInfo* New() const final {
    return CreateMaybeMessage<QueryInfo>(nullptr);
  }

  QueryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QueryInfo& from);
  void MergeFrom(const QueryInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.QueryInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetricTypeFieldNumber = 3,
    kSearchParamsFieldNumber = 4,
    kTopkFieldNumber = 1,
  };
  // string metric_type = 3;
  void clear_metric_type();
  const std::string& metric_type() const;
  void set_metric_type(const std::string& value);
  void set_metric_type(std::string&& value);
  void set_metric_type(const char* value);
  void set_metric_type(const char* value, size_t size);
  std::string* mutable_metric_type();
  std::string* release_metric_type();
  void set_allocated_metric_type(std::string* metric_type);

  // string search_params = 4;
  void clear_search_params();
  const std::string& search_params() const;
  void set_search_params(const std::string& value);
  void set_search_params(std::string&& value);
  void set_search_params(const char* value);
  void set_search_params(const char* value, size_t size);
  std::string* mutable_search_params();
  std::string* release_search_params();
  void set_allocated_search_params(std::string* search_params);

  // int64 topk = 1;
  void clear_topk();
  ::PROTOBUF_NAMESPACE_ID::int64 topk() const;
  void set_topk(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.QueryInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metric_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_params_;
  ::PROTOBUF_NAMESPACE_ID::int64 topk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class ColumnInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.ColumnInfo) */ {
 public:
  ColumnInfo();
  virtual ~ColumnInfo();

  ColumnInfo(const ColumnInfo& from);
  ColumnInfo(ColumnInfo&& from) noexcept
    : ColumnInfo() {
    *this = ::std::move(from);
  }

  inline ColumnInfo& operator=(const ColumnInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnInfo& operator=(ColumnInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColumnInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnInfo* internal_default_instance() {
    return reinterpret_cast<const ColumnInfo*>(
               &_ColumnInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ColumnInfo& a, ColumnInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnInfo* New() const final {
    return CreateMaybeMessage<ColumnInfo>(nullptr);
  }

  ColumnInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColumnInfo& from);
  void MergeFrom(const ColumnInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.ColumnInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldIdFieldNumber = 1,
    kDataTypeFieldNumber = 2,
    kIsPrimaryKeyFieldNumber = 3,
    kIsAutoIDFieldNumber = 4,
  };
  // int64 field_id = 1;
  void clear_field_id();
  ::PROTOBUF_NAMESPACE_ID::int64 field_id() const;
  void set_field_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // .milvus.proto.schema.DataType data_type = 2;
  void clear_data_type();
  ::milvus::proto::schema::DataType data_type() const;
  void set_data_type(::milvus::proto::schema::DataType value);

  // bool is_primary_key = 3;
  void clear_is_primary_key();
  bool is_primary_key() const;
  void set_is_primary_key(bool value);

  // bool is_autoID = 4;
  void clear_is_autoid();
  bool is_autoid() const;
  void set_is_autoid(bool value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.ColumnInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 field_id_;
  int data_type_;
  bool is_primary_key_;
  bool is_autoid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class ValueExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.ValueExpr) */ {
 public:
  ValueExpr();
  virtual ~ValueExpr();

  ValueExpr(const ValueExpr& from);
  ValueExpr(ValueExpr&& from) noexcept
    : ValueExpr() {
    *this = ::std::move(from);
  }

  inline ValueExpr& operator=(const ValueExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueExpr& operator=(ValueExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValueExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValueExpr* internal_default_instance() {
    return reinterpret_cast<const ValueExpr*>(
               &_ValueExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ValueExpr& a, ValueExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValueExpr* New() const final {
    return CreateMaybeMessage<ValueExpr>(nullptr);
  }

  ValueExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValueExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValueExpr& from);
  void MergeFrom(const ValueExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValueExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.ValueExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .milvus.proto.plan.GenericValue value = 1;
  bool has_value() const;
  void clear_value();
  const ::milvus::proto::plan::GenericValue& value() const;
  ::milvus::proto::plan::GenericValue* release_value();
  ::milvus::proto::plan::GenericValue* mutable_value();
  void set_allocated_value(::milvus::proto::plan::GenericValue* value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.ValueExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::GenericValue* value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class ColumnExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.ColumnExpr) */ {
 public:
  ColumnExpr();
  virtual ~ColumnExpr();

  ColumnExpr(const ColumnExpr& from);
  ColumnExpr(ColumnExpr&& from) noexcept
    : ColumnExpr() {
    *this = ::std::move(from);
  }

  inline ColumnExpr& operator=(const ColumnExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnExpr& operator=(ColumnExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColumnExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnExpr* internal_default_instance() {
    return reinterpret_cast<const ColumnExpr*>(
               &_ColumnExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ColumnExpr& a, ColumnExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnExpr* New() const final {
    return CreateMaybeMessage<ColumnExpr>(nullptr);
  }

  ColumnExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColumnExpr& from);
  void MergeFrom(const ColumnExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.ColumnExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnInfoFieldNumber = 1,
  };
  // .milvus.proto.plan.ColumnInfo column_info = 1;
  bool has_column_info() const;
  void clear_column_info();
  const ::milvus::proto::plan::ColumnInfo& column_info() const;
  ::milvus::proto::plan::ColumnInfo* release_column_info();
  ::milvus::proto::plan::ColumnInfo* mutable_column_info();
  void set_allocated_column_info(::milvus::proto::plan::ColumnInfo* column_info);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.ColumnExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::ColumnInfo* column_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class CastExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.CastExpr) */ {
 public:
  CastExpr();
  virtual ~CastExpr();

  CastExpr(const CastExpr& from);
  CastExpr(CastExpr&& from) noexcept
    : CastExpr() {
    *this = ::std::move(from);
  }

  inline CastExpr& operator=(const CastExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CastExpr& operator=(CastExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CastExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CastExpr* internal_default_instance() {
    return reinterpret_cast<const CastExpr*>(
               &_CastExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CastExpr& a, CastExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CastExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CastExpr* New() const final {
    return CreateMaybeMessage<CastExpr>(nullptr);
  }

  CastExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CastExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CastExpr& from);
  void MergeFrom(const CastExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CastExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.CastExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 1,
    kDataTypeFieldNumber = 2,
  };
  // .milvus.proto.plan.Expr child = 1;
  bool has_child() const;
  void clear_child();
  const ::milvus::proto::plan::Expr& child() const;
  ::milvus::proto::plan::Expr* release_child();
  ::milvus::proto::plan::Expr* mutable_child();
  void set_allocated_child(::milvus::proto::plan::Expr* child);

  // .milvus.proto.schema.DataType data_type = 2;
  void clear_data_type();
  ::milvus::proto::schema::DataType data_type() const;
  void set_data_type(::milvus::proto::schema::DataType value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.CastExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::Expr* child_;
  int data_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class UnaryArithExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.UnaryArithExpr) */ {
 public:
  UnaryArithExpr();
  virtual ~UnaryArithExpr();

  UnaryArithExpr(const UnaryArithExpr& from);
  UnaryArithExpr(UnaryArithExpr&& from) noexcept
    : UnaryArithExpr() {
    *this = ::std::move(from);
  }

  inline UnaryArithExpr& operator=(const UnaryArithExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnaryArithExpr& operator=(UnaryArithExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnaryArithExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnaryArithExpr* internal_default_instance() {
    return reinterpret_cast<const UnaryArithExpr*>(
               &_UnaryArithExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UnaryArithExpr& a, UnaryArithExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(UnaryArithExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnaryArithExpr* New() const final {
    return CreateMaybeMessage<UnaryArithExpr>(nullptr);
  }

  UnaryArithExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnaryArithExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnaryArithExpr& from);
  void MergeFrom(const UnaryArithExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnaryArithExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.UnaryArithExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 1,
    kOpFieldNumber = 2,
  };
  // .milvus.proto.plan.Expr child = 1;
  bool has_child() const;
  void clear_child();
  const ::milvus::proto::plan::Expr& child() const;
  ::milvus::proto::plan::Expr* release_child();
  ::milvus::proto::plan::Expr* mutable_child();
  void set_allocated_child(::milvus::proto::plan::Expr* child);

  // .milvus.proto.plan.UnaryArithOp op = 2;
  void clear_op();
  ::milvus::proto::plan::UnaryArithOp op() const;
  void set_op(::milvus::proto::plan::UnaryArithOp value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.UnaryArithExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::Expr* child_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class BinaryArithExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.BinaryArithExpr) */ {
 public:
  BinaryArithExpr();
  virtual ~BinaryArithExpr();

  BinaryArithExpr(const BinaryArithExpr& from);
  BinaryArithExpr(BinaryArithExpr&& from) noexcept
    : BinaryArithExpr() {
    *this = ::std::move(from);
  }

  inline BinaryArithExpr& operator=(const BinaryArithExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryArithExpr& operator=(BinaryArithExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BinaryArithExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryArithExpr* internal_default_instance() {
    return reinterpret_cast<const BinaryArithExpr*>(
               &_BinaryArithExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BinaryArithExpr& a, BinaryArithExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryArithExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinaryArithExpr* New() const final {
    return CreateMaybeMessage<BinaryArithExpr>(nullptr);
  }

  BinaryArithExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinaryArithExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BinaryArithExpr& from);
  void MergeFrom(const BinaryArithExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryArithExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.BinaryArithExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 1,
    kRightFieldNumber = 2,
    kOpFieldNumber = 3,
  };
  // .milvus.proto.plan.Expr left = 1;
  bool has_left() const;
  void clear_left();
  const ::milvus::proto::plan::Expr& left() const;
  ::milvus::proto::plan::Expr* release_left();
  ::milvus::proto::plan::Expr* mutable_left();
  void set_allocated_left(::milvus::proto::plan::Expr* left);

  // .milvus.proto.plan.Expr right = 2;
  bool has_right() const;
  void clear_right();
  const ::milvus::proto::plan::Expr& right() const;
  ::milvus::proto::plan::Expr* release_right();
  ::milvus::proto::plan::Expr* mutable_right();
  void set_allocated_right(::milvus::proto::plan::Expr* right);

  // .milvus.proto.plan.BinaryArithOp op = 3;
  void clear_op();
  ::milvus::proto::plan::BinaryArithOp op() const;
  void set_op(::milvus::proto::plan::BinaryArithOp value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.BinaryArithExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::Expr* left_;
  ::milvus::proto::plan::Expr* right_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class UnaryRangeExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.UnaryRangeExpr) */ {
 public:
  UnaryRangeExpr();
  virtual ~UnaryRangeExpr();

  UnaryRangeExpr(const UnaryRangeExpr& from);
  UnaryRangeExpr(UnaryRangeExpr&& from) noexcept
    : UnaryRangeExpr() {
    *this = ::std::move(from);
  }

  inline UnaryRangeExpr& operator=(const UnaryRangeExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnaryRangeExpr& operator=(UnaryRangeExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnaryRangeExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnaryRangeExpr* internal_default_instance() {
    return reinterpret_cast<const UnaryRangeExpr*>(
               &_UnaryRangeExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UnaryRangeExpr& a, UnaryRangeExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(UnaryRangeExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnaryRangeExpr* New() const final {
    return CreateMaybeMessage<UnaryRangeExpr>(nullptr);
  }

  UnaryRangeExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnaryRangeExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnaryRangeExpr& from);
  void MergeFrom(const UnaryRangeExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnaryRangeExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.UnaryRangeExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 1,
    kValueFieldNumber = 3,
    kOpFieldNumber = 2,
  };
  // .milvus.proto.plan.Expr child = 1;
  bool has_child() const;
  void clear_child();
  const ::milvus::proto::plan::Expr& child() const;
  ::milvus::proto::plan::Expr* release_child();
  ::milvus::proto::plan::Expr* mutable_child();
  void set_allocated_child(::milvus::proto::plan::Expr* child);

  // .milvus.proto.plan.GenericValue value = 3;
  bool has_value() const;
  void clear_value();
  const ::milvus::proto::plan::GenericValue& value() const;
  ::milvus::proto::plan::GenericValue* release_value();
  ::milvus::proto::plan::GenericValue* mutable_value();
  void set_allocated_value(::milvus::proto::plan::GenericValue* value);

  // .milvus.proto.plan.CompareOp op = 2;
  void clear_op();
  ::milvus::proto::plan::CompareOp op() const;
  void set_op(::milvus::proto::plan::CompareOp value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.UnaryRangeExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::Expr* child_;
  ::milvus::proto::plan::GenericValue* value_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class BinaryRangeExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.BinaryRangeExpr) */ {
 public:
  BinaryRangeExpr();
  virtual ~BinaryRangeExpr();

  BinaryRangeExpr(const BinaryRangeExpr& from);
  BinaryRangeExpr(BinaryRangeExpr&& from) noexcept
    : BinaryRangeExpr() {
    *this = ::std::move(from);
  }

  inline BinaryRangeExpr& operator=(const BinaryRangeExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryRangeExpr& operator=(BinaryRangeExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BinaryRangeExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryRangeExpr* internal_default_instance() {
    return reinterpret_cast<const BinaryRangeExpr*>(
               &_BinaryRangeExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BinaryRangeExpr& a, BinaryRangeExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryRangeExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinaryRangeExpr* New() const final {
    return CreateMaybeMessage<BinaryRangeExpr>(nullptr);
  }

  BinaryRangeExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinaryRangeExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BinaryRangeExpr& from);
  void MergeFrom(const BinaryRangeExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryRangeExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.BinaryRangeExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 1,
    kLowerValueFieldNumber = 4,
    kUpperValueFieldNumber = 5,
    kLowerInclusiveFieldNumber = 2,
    kUpperInclusiveFieldNumber = 3,
  };
  // .milvus.proto.plan.Expr child = 1;
  bool has_child() const;
  void clear_child();
  const ::milvus::proto::plan::Expr& child() const;
  ::milvus::proto::plan::Expr* release_child();
  ::milvus::proto::plan::Expr* mutable_child();
  void set_allocated_child(::milvus::proto::plan::Expr* child);

  // .milvus.proto.plan.GenericValue lower_value = 4;
  bool has_lower_value() const;
  void clear_lower_value();
  const ::milvus::proto::plan::GenericValue& lower_value() const;
  ::milvus::proto::plan::GenericValue* release_lower_value();
  ::milvus::proto::plan::GenericValue* mutable_lower_value();
  void set_allocated_lower_value(::milvus::proto::plan::GenericValue* lower_value);

  // .milvus.proto.plan.GenericValue upper_value = 5;
  bool has_upper_value() const;
  void clear_upper_value();
  const ::milvus::proto::plan::GenericValue& upper_value() const;
  ::milvus::proto::plan::GenericValue* release_upper_value();
  ::milvus::proto::plan::GenericValue* mutable_upper_value();
  void set_allocated_upper_value(::milvus::proto::plan::GenericValue* upper_value);

  // bool lower_inclusive = 2;
  void clear_lower_inclusive();
  bool lower_inclusive() const;
  void set_lower_inclusive(bool value);

  // bool upper_inclusive = 3;
  void clear_upper_inclusive();
  bool upper_inclusive() const;
  void set_upper_inclusive(bool value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.BinaryRangeExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::Expr* child_;
  ::milvus::proto::plan::GenericValue* lower_value_;
  ::milvus::proto::plan::GenericValue* upper_value_;
  bool lower_inclusive_;
  bool upper_inclusive_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class CompareExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.CompareExpr) */ {
 public:
  CompareExpr();
  virtual ~CompareExpr();

  CompareExpr(const CompareExpr& from);
  CompareExpr(CompareExpr&& from) noexcept
    : CompareExpr() {
    *this = ::std::move(from);
  }

  inline CompareExpr& operator=(const CompareExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompareExpr& operator=(CompareExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CompareExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompareExpr* internal_default_instance() {
    return reinterpret_cast<const CompareExpr*>(
               &_CompareExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CompareExpr& a, CompareExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(CompareExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompareExpr* New() const final {
    return CreateMaybeMessage<CompareExpr>(nullptr);
  }

  CompareExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompareExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CompareExpr& from);
  void MergeFrom(const CompareExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompareExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.CompareExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 1,
    kRightFieldNumber = 2,
    kOpFieldNumber = 3,
  };
  // .milvus.proto.plan.Expr left = 1;
  bool has_left() const;
  void clear_left();
  const ::milvus::proto::plan::Expr& left() const;
  ::milvus::proto::plan::Expr* release_left();
  ::milvus::proto::plan::Expr* mutable_left();
  void set_allocated_left(::milvus::proto::plan::Expr* left);

  // .milvus.proto.plan.Expr right = 2;
  bool has_right() const;
  void clear_right();
  const ::milvus::proto::plan::Expr& right() const;
  ::milvus::proto::plan::Expr* release_right();
  ::milvus::proto::plan::Expr* mutable_right();
  void set_allocated_right(::milvus::proto::plan::Expr* right);

  // .milvus.proto.plan.CompareOp op = 3;
  void clear_op();
  ::milvus::proto::plan::CompareOp op() const;
  void set_op(::milvus::proto::plan::CompareOp value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.CompareExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::Expr* left_;
  ::milvus::proto::plan::Expr* right_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class TermExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.TermExpr) */ {
 public:
  TermExpr();
  virtual ~TermExpr();

  TermExpr(const TermExpr& from);
  TermExpr(TermExpr&& from) noexcept
    : TermExpr() {
    *this = ::std::move(from);
  }

  inline TermExpr& operator=(const TermExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline TermExpr& operator=(TermExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TermExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TermExpr* internal_default_instance() {
    return reinterpret_cast<const TermExpr*>(
               &_TermExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TermExpr& a, TermExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(TermExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TermExpr* New() const final {
    return CreateMaybeMessage<TermExpr>(nullptr);
  }

  TermExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TermExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TermExpr& from);
  void MergeFrom(const TermExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TermExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.TermExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kChildFieldNumber = 1,
  };
  // repeated .milvus.proto.plan.GenericValue values = 2;
  int values_size() const;
  void clear_values();
  ::milvus::proto::plan::GenericValue* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::milvus::proto::plan::GenericValue >*
      mutable_values();
  const ::milvus::proto::plan::GenericValue& values(int index) const;
  ::milvus::proto::plan::GenericValue* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::milvus::proto::plan::GenericValue >&
      values() const;

  // .milvus.proto.plan.Expr child = 1;
  bool has_child() const;
  void clear_child();
  const ::milvus::proto::plan::Expr& child() const;
  ::milvus::proto::plan::Expr* release_child();
  ::milvus::proto::plan::Expr* mutable_child();
  void set_allocated_child(::milvus::proto::plan::Expr* child);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.TermExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::milvus::proto::plan::GenericValue > values_;
  ::milvus::proto::plan::Expr* child_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class UnaryLogicalExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.UnaryLogicalExpr) */ {
 public:
  UnaryLogicalExpr();
  virtual ~UnaryLogicalExpr();

  UnaryLogicalExpr(const UnaryLogicalExpr& from);
  UnaryLogicalExpr(UnaryLogicalExpr&& from) noexcept
    : UnaryLogicalExpr() {
    *this = ::std::move(from);
  }

  inline UnaryLogicalExpr& operator=(const UnaryLogicalExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnaryLogicalExpr& operator=(UnaryLogicalExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnaryLogicalExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnaryLogicalExpr* internal_default_instance() {
    return reinterpret_cast<const UnaryLogicalExpr*>(
               &_UnaryLogicalExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UnaryLogicalExpr& a, UnaryLogicalExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(UnaryLogicalExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnaryLogicalExpr* New() const final {
    return CreateMaybeMessage<UnaryLogicalExpr>(nullptr);
  }

  UnaryLogicalExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnaryLogicalExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnaryLogicalExpr& from);
  void MergeFrom(const UnaryLogicalExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnaryLogicalExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.UnaryLogicalExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 1,
    kOpFieldNumber = 2,
  };
  // .milvus.proto.plan.Expr child = 1;
  bool has_child() const;
  void clear_child();
  const ::milvus::proto::plan::Expr& child() const;
  ::milvus::proto::plan::Expr* release_child();
  ::milvus::proto::plan::Expr* mutable_child();
  void set_allocated_child(::milvus::proto::plan::Expr* child);

  // .milvus.proto.plan.UnaryLogicalOp op = 2;
  void clear_op();
  ::milvus::proto::plan::UnaryLogicalOp op() const;
  void set_op(::milvus::proto::plan::UnaryLogicalOp value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.UnaryLogicalExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::Expr* child_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class BinaryLogicalExpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.BinaryLogicalExpr) */ {
 public:
  BinaryLogicalExpr();
  virtual ~BinaryLogicalExpr();

  BinaryLogicalExpr(const BinaryLogicalExpr& from);
  BinaryLogicalExpr(BinaryLogicalExpr&& from) noexcept
    : BinaryLogicalExpr() {
    *this = ::std::move(from);
  }

  inline BinaryLogicalExpr& operator=(const BinaryLogicalExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryLogicalExpr& operator=(BinaryLogicalExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BinaryLogicalExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryLogicalExpr* internal_default_instance() {
    return reinterpret_cast<const BinaryLogicalExpr*>(
               &_BinaryLogicalExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BinaryLogicalExpr& a, BinaryLogicalExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryLogicalExpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinaryLogicalExpr* New() const final {
    return CreateMaybeMessage<BinaryLogicalExpr>(nullptr);
  }

  BinaryLogicalExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinaryLogicalExpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BinaryLogicalExpr& from);
  void MergeFrom(const BinaryLogicalExpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryLogicalExpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.BinaryLogicalExpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftFieldNumber = 1,
    kRightFieldNumber = 2,
    kOpFieldNumber = 3,
  };
  // .milvus.proto.plan.Expr left = 1;
  bool has_left() const;
  void clear_left();
  const ::milvus::proto::plan::Expr& left() const;
  ::milvus::proto::plan::Expr* release_left();
  ::milvus::proto::plan::Expr* mutable_left();
  void set_allocated_left(::milvus::proto::plan::Expr* left);

  // .milvus.proto.plan.Expr right = 2;
  bool has_right() const;
  void clear_right();
  const ::milvus::proto::plan::Expr& right() const;
  ::milvus::proto::plan::Expr* release_right();
  ::milvus::proto::plan::Expr* mutable_right();
  void set_allocated_right(::milvus::proto::plan::Expr* right);

  // .milvus.proto.plan.BinaryLogicalOp op = 3;
  void clear_op();
  ::milvus::proto::plan::BinaryLogicalOp op() const;
  void set_op(::milvus::proto::plan::BinaryLogicalOp value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.BinaryLogicalExpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::milvus::proto::plan::Expr* left_;
  ::milvus::proto::plan::Expr* right_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class Expr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.Expr) */ {
 public:
  Expr();
  virtual ~Expr();

  Expr(const Expr& from);
  Expr(Expr&& from) noexcept
    : Expr() {
    *this = ::std::move(from);
  }

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }
  inline Expr& operator=(Expr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Expr& default_instance();

  enum ExprCase {
    kTermExpr = 1,
    kCompareExpr = 2,
    kUnaryLogicalExpr = 3,
    kBinaryLogicalExpr = 4,
    kUnaryRangeExpr = 5,
    kBinaryRangeExpr = 6,
    kUnaryArithExpr = 7,
    kBinaryArithExpr = 8,
    kValueExpr = 9,
    kColumnExpr = 10,
    kCastExpr = 11,
    EXPR_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expr* internal_default_instance() {
    return reinterpret_cast<const Expr*>(
               &_Expr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Expr& a, Expr& b) {
    a.Swap(&b);
  }
  inline void Swap(Expr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Expr* New() const final {
    return CreateMaybeMessage<Expr>(nullptr);
  }

  Expr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Expr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Expr& from);
  void MergeFrom(const Expr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.Expr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermExprFieldNumber = 1,
    kCompareExprFieldNumber = 2,
    kUnaryLogicalExprFieldNumber = 3,
    kBinaryLogicalExprFieldNumber = 4,
    kUnaryRangeExprFieldNumber = 5,
    kBinaryRangeExprFieldNumber = 6,
    kUnaryArithExprFieldNumber = 7,
    kBinaryArithExprFieldNumber = 8,
    kValueExprFieldNumber = 9,
    kColumnExprFieldNumber = 10,
    kCastExprFieldNumber = 11,
  };
  // .milvus.proto.plan.TermExpr term_expr = 1;
  bool has_term_expr() const;
  void clear_term_expr();
  const ::milvus::proto::plan::TermExpr& term_expr() const;
  ::milvus::proto::plan::TermExpr* release_term_expr();
  ::milvus::proto::plan::TermExpr* mutable_term_expr();
  void set_allocated_term_expr(::milvus::proto::plan::TermExpr* term_expr);

  // .milvus.proto.plan.CompareExpr compare_expr = 2;
  bool has_compare_expr() const;
  void clear_compare_expr();
  const ::milvus::proto::plan::CompareExpr& compare_expr() const;
  ::milvus::proto::plan::CompareExpr* release_compare_expr();
  ::milvus::proto::plan::CompareExpr* mutable_compare_expr();
  void set_allocated_compare_expr(::milvus::proto::plan::CompareExpr* compare_expr);

  // .milvus.proto.plan.UnaryLogicalExpr unary_logical_expr = 3;
  bool has_unary_logical_expr() const;
  void clear_unary_logical_expr();
  const ::milvus::proto::plan::UnaryLogicalExpr& unary_logical_expr() const;
  ::milvus::proto::plan::UnaryLogicalExpr* release_unary_logical_expr();
  ::milvus::proto::plan::UnaryLogicalExpr* mutable_unary_logical_expr();
  void set_allocated_unary_logical_expr(::milvus::proto::plan::UnaryLogicalExpr* unary_logical_expr);

  // .milvus.proto.plan.BinaryLogicalExpr binary_logical_expr = 4;
  bool has_binary_logical_expr() const;
  void clear_binary_logical_expr();
  const ::milvus::proto::plan::BinaryLogicalExpr& binary_logical_expr() const;
  ::milvus::proto::plan::BinaryLogicalExpr* release_binary_logical_expr();
  ::milvus::proto::plan::BinaryLogicalExpr* mutable_binary_logical_expr();
  void set_allocated_binary_logical_expr(::milvus::proto::plan::BinaryLogicalExpr* binary_logical_expr);

  // .milvus.proto.plan.UnaryRangeExpr unary_range_expr = 5;
  bool has_unary_range_expr() const;
  void clear_unary_range_expr();
  const ::milvus::proto::plan::UnaryRangeExpr& unary_range_expr() const;
  ::milvus::proto::plan::UnaryRangeExpr* release_unary_range_expr();
  ::milvus::proto::plan::UnaryRangeExpr* mutable_unary_range_expr();
  void set_allocated_unary_range_expr(::milvus::proto::plan::UnaryRangeExpr* unary_range_expr);

  // .milvus.proto.plan.BinaryRangeExpr binary_range_expr = 6;
  bool has_binary_range_expr() const;
  void clear_binary_range_expr();
  const ::milvus::proto::plan::BinaryRangeExpr& binary_range_expr() const;
  ::milvus::proto::plan::BinaryRangeExpr* release_binary_range_expr();
  ::milvus::proto::plan::BinaryRangeExpr* mutable_binary_range_expr();
  void set_allocated_binary_range_expr(::milvus::proto::plan::BinaryRangeExpr* binary_range_expr);

  // .milvus.proto.plan.UnaryArithExpr unary_arith_expr = 7;
  bool has_unary_arith_expr() const;
  void clear_unary_arith_expr();
  const ::milvus::proto::plan::UnaryArithExpr& unary_arith_expr() const;
  ::milvus::proto::plan::UnaryArithExpr* release_unary_arith_expr();
  ::milvus::proto::plan::UnaryArithExpr* mutable_unary_arith_expr();
  void set_allocated_unary_arith_expr(::milvus::proto::plan::UnaryArithExpr* unary_arith_expr);

  // .milvus.proto.plan.BinaryArithExpr binary_arith_expr = 8;
  bool has_binary_arith_expr() const;
  void clear_binary_arith_expr();
  const ::milvus::proto::plan::BinaryArithExpr& binary_arith_expr() const;
  ::milvus::proto::plan::BinaryArithExpr* release_binary_arith_expr();
  ::milvus::proto::plan::BinaryArithExpr* mutable_binary_arith_expr();
  void set_allocated_binary_arith_expr(::milvus::proto::plan::BinaryArithExpr* binary_arith_expr);

  // .milvus.proto.plan.ValueExpr value_expr = 9;
  bool has_value_expr() const;
  void clear_value_expr();
  const ::milvus::proto::plan::ValueExpr& value_expr() const;
  ::milvus::proto::plan::ValueExpr* release_value_expr();
  ::milvus::proto::plan::ValueExpr* mutable_value_expr();
  void set_allocated_value_expr(::milvus::proto::plan::ValueExpr* value_expr);

  // .milvus.proto.plan.ColumnExpr column_expr = 10;
  bool has_column_expr() const;
  void clear_column_expr();
  const ::milvus::proto::plan::ColumnExpr& column_expr() const;
  ::milvus::proto::plan::ColumnExpr* release_column_expr();
  ::milvus::proto::plan::ColumnExpr* mutable_column_expr();
  void set_allocated_column_expr(::milvus::proto::plan::ColumnExpr* column_expr);

  // .milvus.proto.plan.CastExpr cast_expr = 11;
  bool has_cast_expr() const;
  void clear_cast_expr();
  const ::milvus::proto::plan::CastExpr& cast_expr() const;
  ::milvus::proto::plan::CastExpr* release_cast_expr();
  ::milvus::proto::plan::CastExpr* mutable_cast_expr();
  void set_allocated_cast_expr(::milvus::proto::plan::CastExpr* cast_expr);

  void clear_expr();
  ExprCase expr_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.Expr)
 private:
  class _Internal;
  void set_has_term_expr();
  void set_has_compare_expr();
  void set_has_unary_logical_expr();
  void set_has_binary_logical_expr();
  void set_has_unary_range_expr();
  void set_has_binary_range_expr();
  void set_has_unary_arith_expr();
  void set_has_binary_arith_expr();
  void set_has_value_expr();
  void set_has_column_expr();
  void set_has_cast_expr();

  inline bool has_expr() const;
  inline void clear_has_expr();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union ExprUnion {
    ExprUnion() {}
    ::milvus::proto::plan::TermExpr* term_expr_;
    ::milvus::proto::plan::CompareExpr* compare_expr_;
    ::milvus::proto::plan::UnaryLogicalExpr* unary_logical_expr_;
    ::milvus::proto::plan::BinaryLogicalExpr* binary_logical_expr_;
    ::milvus::proto::plan::UnaryRangeExpr* unary_range_expr_;
    ::milvus::proto::plan::BinaryRangeExpr* binary_range_expr_;
    ::milvus::proto::plan::UnaryArithExpr* unary_arith_expr_;
    ::milvus::proto::plan::BinaryArithExpr* binary_arith_expr_;
    ::milvus::proto::plan::ValueExpr* value_expr_;
    ::milvus::proto::plan::ColumnExpr* column_expr_;
    ::milvus::proto::plan::CastExpr* cast_expr_;
  } expr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class VectorANNS :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.VectorANNS) */ {
 public:
  VectorANNS();
  virtual ~VectorANNS();

  VectorANNS(const VectorANNS& from);
  VectorANNS(VectorANNS&& from) noexcept
    : VectorANNS() {
    *this = ::std::move(from);
  }

  inline VectorANNS& operator=(const VectorANNS& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorANNS& operator=(VectorANNS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VectorANNS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VectorANNS* internal_default_instance() {
    return reinterpret_cast<const VectorANNS*>(
               &_VectorANNS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(VectorANNS& a, VectorANNS& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorANNS* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VectorANNS* New() const final {
    return CreateMaybeMessage<VectorANNS>(nullptr);
  }

  VectorANNS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VectorANNS>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VectorANNS& from);
  void MergeFrom(const VectorANNS& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorANNS* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.VectorANNS";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlaceholderTagFieldNumber = 5,
    kPredicatesFieldNumber = 3,
    kQueryInfoFieldNumber = 4,
    kFieldIdFieldNumber = 2,
    kIsBinaryFieldNumber = 1,
  };
  // string placeholder_tag = 5;
  void clear_placeholder_tag();
  const std::string& placeholder_tag() const;
  void set_placeholder_tag(const std::string& value);
  void set_placeholder_tag(std::string&& value);
  void set_placeholder_tag(const char* value);
  void set_placeholder_tag(const char* value, size_t size);
  std::string* mutable_placeholder_tag();
  std::string* release_placeholder_tag();
  void set_allocated_placeholder_tag(std::string* placeholder_tag);

  // .milvus.proto.plan.Expr predicates = 3;
  bool has_predicates() const;
  void clear_predicates();
  const ::milvus::proto::plan::Expr& predicates() const;
  ::milvus::proto::plan::Expr* release_predicates();
  ::milvus::proto::plan::Expr* mutable_predicates();
  void set_allocated_predicates(::milvus::proto::plan::Expr* predicates);

  // .milvus.proto.plan.QueryInfo query_info = 4;
  bool has_query_info() const;
  void clear_query_info();
  const ::milvus::proto::plan::QueryInfo& query_info() const;
  ::milvus::proto::plan::QueryInfo* release_query_info();
  ::milvus::proto::plan::QueryInfo* mutable_query_info();
  void set_allocated_query_info(::milvus::proto::plan::QueryInfo* query_info);

  // int64 field_id = 2;
  void clear_field_id();
  ::PROTOBUF_NAMESPACE_ID::int64 field_id() const;
  void set_field_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // bool is_binary = 1;
  void clear_is_binary();
  bool is_binary() const;
  void set_is_binary(bool value);

  // @@protoc_insertion_point(class_scope:milvus.proto.plan.VectorANNS)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr placeholder_tag_;
  ::milvus::proto::plan::Expr* predicates_;
  ::milvus::proto::plan::QueryInfo* query_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 field_id_;
  bool is_binary_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class PlanNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:milvus.proto.plan.PlanNode) */ {
 public:
  PlanNode();
  virtual ~PlanNode();

  PlanNode(const PlanNode& from);
  PlanNode(PlanNode&& from) noexcept
    : PlanNode() {
    *this = ::std::move(from);
  }

  inline PlanNode& operator=(const PlanNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanNode& operator=(PlanNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlanNode& default_instance();

  enum NodeCase {
    kVectorAnns = 1,
    kPredicates = 2,
    NODE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanNode* internal_default_instance() {
    return reinterpret_cast<const PlanNode*>(
               &_PlanNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PlanNode& a, PlanNode& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanNode* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlanNode* New() const final {
    return CreateMaybeMessage<PlanNode>(nullptr);
  }

  PlanNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlanNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlanNode& from);
  void MergeFrom(const PlanNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "milvus.proto.plan.PlanNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_plan_2eproto);
    return ::descriptor_table_plan_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputFieldIdsFieldNumber = 3,
    kVectorAnnsFieldNumber = 1,
    kPredicatesFieldNumber = 2,
  };
  // repeated int64 output_field_ids = 3;
  int output_field_ids_size() const;
  void clear_output_field_ids();
  ::PROTOBUF_NAMESPACE_ID::int64 output_field_ids(int index) const;
  void set_output_field_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_output_field_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      output_field_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_output_field_ids();

  // .milvus.proto.plan.VectorANNS vector_anns = 1;
  bool has_vector_anns() const;
  void clear_vector_anns();
  const ::milvus::proto::plan::VectorANNS& vector_anns() const;
  ::milvus::proto::plan::VectorANNS* release_vector_anns();
  ::milvus::proto::plan::VectorANNS* mutable_vector_anns();
  void set_allocated_vector_anns(::milvus::proto::plan::VectorANNS* vector_anns);

  // .milvus.proto.plan.Expr predicates = 2;
  bool has_predicates() const;
  void clear_predicates();
  const ::milvus::proto::plan::Expr& predicates() const;
  ::milvus::proto::plan::Expr* release_predicates();
  ::milvus::proto::plan::Expr* mutable_predicates();
  void set_allocated_predicates(::milvus::proto::plan::Expr* predicates);

  void clear_node();
  NodeCase node_case() const;
  // @@protoc_insertion_point(class_scope:milvus.proto.plan.PlanNode)
 private:
  class _Internal;
  void set_has_vector_anns();
  void set_has_predicates();

  inline bool has_node() const;
  inline void clear_has_node();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > output_field_ids_;
  mutable std::atomic<int> _output_field_ids_cached_byte_size_;
  union NodeUnion {
    NodeUnion() {}
    ::milvus::proto::plan::VectorANNS* vector_anns_;
    ::milvus::proto::plan::Expr* predicates_;
  } node_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_plan_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GenericValue

// bool bool_val = 1;
inline bool GenericValue::has_bool_val() const {
  return val_case() == kBoolVal;
}
inline void GenericValue::set_has_bool_val() {
  _oneof_case_[0] = kBoolVal;
}
inline void GenericValue::clear_bool_val() {
  if (has_bool_val()) {
    val_.bool_val_ = false;
    clear_has_val();
  }
}
inline bool GenericValue::bool_val() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.GenericValue.bool_val)
  if (has_bool_val()) {
    return val_.bool_val_;
  }
  return false;
}
inline void GenericValue::set_bool_val(bool value) {
  if (!has_bool_val()) {
    clear_val();
    set_has_bool_val();
  }
  val_.bool_val_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.GenericValue.bool_val)
}

// int64 int64_val = 2;
inline bool GenericValue::has_int64_val() const {
  return val_case() == kInt64Val;
}
inline void GenericValue::set_has_int64_val() {
  _oneof_case_[0] = kInt64Val;
}
inline void GenericValue::clear_int64_val() {
  if (has_int64_val()) {
    val_.int64_val_ = PROTOBUF_LONGLONG(0);
    clear_has_val();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GenericValue::int64_val() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.GenericValue.int64_val)
  if (has_int64_val()) {
    return val_.int64_val_;
  }
  return PROTOBUF_LONGLONG(0);
}
inline void GenericValue::set_int64_val(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!has_int64_val()) {
    clear_val();
    set_has_int64_val();
  }
  val_.int64_val_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.GenericValue.int64_val)
}

// double float_val = 3;
inline bool GenericValue::has_float_val() const {
  return val_case() == kFloatVal;
}
inline void GenericValue::set_has_float_val() {
  _oneof_case_[0] = kFloatVal;
}
inline void GenericValue::clear_float_val() {
  if (has_float_val()) {
    val_.float_val_ = 0;
    clear_has_val();
  }
}
inline double GenericValue::float_val() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.GenericValue.float_val)
  if (has_float_val()) {
    return val_.float_val_;
  }
  return 0;
}
inline void GenericValue::set_float_val(double value) {
  if (!has_float_val()) {
    clear_val();
    set_has_float_val();
  }
  val_.float_val_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.GenericValue.float_val)
}

inline bool GenericValue::has_val() const {
  return val_case() != VAL_NOT_SET;
}
inline void GenericValue::clear_has_val() {
  _oneof_case_[0] = VAL_NOT_SET;
}
inline GenericValue::ValCase GenericValue::val_case() const {
  return GenericValue::ValCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// QueryInfo

// int64 topk = 1;
inline void QueryInfo::clear_topk() {
  topk_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryInfo::topk() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryInfo.topk)
  return topk_;
}
inline void QueryInfo::set_topk(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  topk_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.QueryInfo.topk)
}

// string metric_type = 3;
inline void QueryInfo::clear_metric_type() {
  metric_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& QueryInfo::metric_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryInfo.metric_type)
  return metric_type_.GetNoArena();
}
inline void QueryInfo::set_metric_type(const std::string& value) {
  
  metric_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.QueryInfo.metric_type)
}
inline void QueryInfo::set_metric_type(std::string&& value) {
  
  metric_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:milvus.proto.plan.QueryInfo.metric_type)
}
inline void QueryInfo::set_metric_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  metric_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:milvus.proto.plan.QueryInfo.metric_type)
}
inline void QueryInfo::set_metric_type(const char* value, size_t size) {
  
  metric_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:milvus.proto.plan.QueryInfo.metric_type)
}
inline std::string* QueryInfo::mutable_metric_type() {
  
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.QueryInfo.metric_type)
  return metric_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* QueryInfo::release_metric_type() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.QueryInfo.metric_type)
  
  return metric_type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void QueryInfo::set_allocated_metric_type(std::string* metric_type) {
  if (metric_type != nullptr) {
    
  } else {
    
  }
  metric_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), metric_type);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.QueryInfo.metric_type)
}

// string search_params = 4;
inline void QueryInfo::clear_search_params() {
  search_params_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& QueryInfo::search_params() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.QueryInfo.search_params)
  return search_params_.GetNoArena();
}
inline void QueryInfo::set_search_params(const std::string& value) {
  
  search_params_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.QueryInfo.search_params)
}
inline void QueryInfo::set_search_params(std::string&& value) {
  
  search_params_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:milvus.proto.plan.QueryInfo.search_params)
}
inline void QueryInfo::set_search_params(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  search_params_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:milvus.proto.plan.QueryInfo.search_params)
}
inline void QueryInfo::set_search_params(const char* value, size_t size) {
  
  search_params_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:milvus.proto.plan.QueryInfo.search_params)
}
inline std::string* QueryInfo::mutable_search_params() {
  
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.QueryInfo.search_params)
  return search_params_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* QueryInfo::release_search_params() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.QueryInfo.search_params)
  
  return search_params_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void QueryInfo::set_allocated_search_params(std::string* search_params) {
  if (search_params != nullptr) {
    
  } else {
    
  }
  search_params_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), search_params);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.QueryInfo.search_params)
}

// -------------------------------------------------------------------

// ColumnInfo

// int64 field_id = 1;
inline void ColumnInfo::clear_field_id() {
  field_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ColumnInfo::field_id() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.field_id)
  return field_id_;
}
inline void ColumnInfo::set_field_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  field_id_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.field_id)
}

// .milvus.proto.schema.DataType data_type = 2;
inline void ColumnInfo::clear_data_type() {
  data_type_ = 0;
}
inline ::milvus::proto::schema::DataType ColumnInfo::data_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.data_type)
  return static_cast< ::milvus::proto::schema::DataType >(data_type_);
}
inline void ColumnInfo::set_data_type(::milvus::proto::schema::DataType value) {
  
  data_type_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.data_type)
}

// bool is_primary_key = 3;
inline void ColumnInfo::clear_is_primary_key() {
  is_primary_key_ = false;
}
inline bool ColumnInfo::is_primary_key() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.is_primary_key)
  return is_primary_key_;
}
inline void ColumnInfo::set_is_primary_key(bool value) {
  
  is_primary_key_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.is_primary_key)
}

// bool is_autoID = 4;
inline void ColumnInfo::clear_is_autoid() {
  is_autoid_ = false;
}
inline bool ColumnInfo::is_autoid() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnInfo.is_autoID)
  return is_autoid_;
}
inline void ColumnInfo::set_is_autoid(bool value) {
  
  is_autoid_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.ColumnInfo.is_autoID)
}

// -------------------------------------------------------------------

// ValueExpr

// .milvus.proto.plan.GenericValue value = 1;
inline bool ValueExpr::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline void ValueExpr::clear_value() {
  if (GetArenaNoVirtual() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::milvus::proto::plan::GenericValue& ValueExpr::value() const {
  const ::milvus::proto::plan::GenericValue* p = value_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ValueExpr.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::GenericValue*>(
      &::milvus::proto::plan::_GenericValue_default_instance_);
}
inline ::milvus::proto::plan::GenericValue* ValueExpr::release_value() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.ValueExpr.value)
  
  ::milvus::proto::plan::GenericValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* ValueExpr::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.ValueExpr.value)
  return value_;
}
inline void ValueExpr::set_allocated_value(::milvus::proto::plan::GenericValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.ValueExpr.value)
}

// -------------------------------------------------------------------

// ColumnExpr

// .milvus.proto.plan.ColumnInfo column_info = 1;
inline bool ColumnExpr::has_column_info() const {
  return this != internal_default_instance() && column_info_ != nullptr;
}
inline void ColumnExpr::clear_column_info() {
  if (GetArenaNoVirtual() == nullptr && column_info_ != nullptr) {
    delete column_info_;
  }
  column_info_ = nullptr;
}
inline const ::milvus::proto::plan::ColumnInfo& ColumnExpr::column_info() const {
  const ::milvus::proto::plan::ColumnInfo* p = column_info_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.ColumnExpr.column_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::ColumnInfo*>(
      &::milvus::proto::plan::_ColumnInfo_default_instance_);
}
inline ::milvus::proto::plan::ColumnInfo* ColumnExpr::release_column_info() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.ColumnExpr.column_info)
  
  ::milvus::proto::plan::ColumnInfo* temp = column_info_;
  column_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::ColumnInfo* ColumnExpr::mutable_column_info() {
  
  if (column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::ColumnInfo>(GetArenaNoVirtual());
    column_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.ColumnExpr.column_info)
  return column_info_;
}
inline void ColumnExpr::set_allocated_column_info(::milvus::proto::plan::ColumnInfo* column_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete column_info_;
  }
  if (column_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      column_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_info, submessage_arena);
    }
    
  } else {
    
  }
  column_info_ = column_info;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.ColumnExpr.column_info)
}

// -------------------------------------------------------------------

// CastExpr

// .milvus.proto.plan.Expr child = 1;
inline bool CastExpr::has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline void CastExpr::clear_child() {
  if (GetArenaNoVirtual() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& CastExpr::child() const {
  const ::milvus::proto::plan::Expr* p = child_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.CastExpr.child)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* CastExpr::release_child() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.CastExpr.child)
  
  ::milvus::proto::plan::Expr* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* CastExpr::mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.CastExpr.child)
  return child_;
}
inline void CastExpr::set_allocated_child(::milvus::proto::plan::Expr* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.CastExpr.child)
}

// .milvus.proto.schema.DataType data_type = 2;
inline void CastExpr::clear_data_type() {
  data_type_ = 0;
}
inline ::milvus::proto::schema::DataType CastExpr::data_type() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.CastExpr.data_type)
  return static_cast< ::milvus::proto::schema::DataType >(data_type_);
}
inline void CastExpr::set_data_type(::milvus::proto::schema::DataType value) {
  
  data_type_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.CastExpr.data_type)
}

// -------------------------------------------------------------------

// UnaryArithExpr

// .milvus.proto.plan.Expr child = 1;
inline bool UnaryArithExpr::has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline void UnaryArithExpr::clear_child() {
  if (GetArenaNoVirtual() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& UnaryArithExpr::child() const {
  const ::milvus::proto::plan::Expr* p = child_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryArithExpr.child)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* UnaryArithExpr::release_child() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.UnaryArithExpr.child)
  
  ::milvus::proto::plan::Expr* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* UnaryArithExpr::mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.UnaryArithExpr.child)
  return child_;
}
inline void UnaryArithExpr::set_allocated_child(::milvus::proto::plan::Expr* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.UnaryArithExpr.child)
}

// .milvus.proto.plan.UnaryArithOp op = 2;
inline void UnaryArithExpr::clear_op() {
  op_ = 0;
}
inline ::milvus::proto::plan::UnaryArithOp UnaryArithExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryArithExpr.op)
  return static_cast< ::milvus::proto::plan::UnaryArithOp >(op_);
}
inline void UnaryArithExpr::set_op(::milvus::proto::plan::UnaryArithOp value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.UnaryArithExpr.op)
}

// -------------------------------------------------------------------

// BinaryArithExpr

// .milvus.proto.plan.Expr left = 1;
inline bool BinaryArithExpr::has_left() const {
  return this != internal_default_instance() && left_ != nullptr;
}
inline void BinaryArithExpr::clear_left() {
  if (GetArenaNoVirtual() == nullptr && left_ != nullptr) {
    delete left_;
  }
  left_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& BinaryArithExpr::left() const {
  const ::milvus::proto::plan::Expr* p = left_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithExpr.left)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* BinaryArithExpr::release_left() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryArithExpr.left)
  
  ::milvus::proto::plan::Expr* temp = left_;
  left_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* BinaryArithExpr::mutable_left() {
  
  if (left_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryArithExpr.left)
  return left_;
}
inline void BinaryArithExpr::set_allocated_left(::milvus::proto::plan::Expr* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete left_;
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryArithExpr.left)
}

// .milvus.proto.plan.Expr right = 2;
inline bool BinaryArithExpr::has_right() const {
  return this != internal_default_instance() && right_ != nullptr;
}
inline void BinaryArithExpr::clear_right() {
  if (GetArenaNoVirtual() == nullptr && right_ != nullptr) {
    delete right_;
  }
  right_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& BinaryArithExpr::right() const {
  const ::milvus::proto::plan::Expr* p = right_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithExpr.right)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* BinaryArithExpr::release_right() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryArithExpr.right)
  
  ::milvus::proto::plan::Expr* temp = right_;
  right_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* BinaryArithExpr::mutable_right() {
  
  if (right_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryArithExpr.right)
  return right_;
}
inline void BinaryArithExpr::set_allocated_right(::milvus::proto::plan::Expr* right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete right_;
  }
  if (right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryArithExpr.right)
}

// .milvus.proto.plan.BinaryArithOp op = 3;
inline void BinaryArithExpr::clear_op() {
  op_ = 0;
}
inline ::milvus::proto::plan::BinaryArithOp BinaryArithExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryArithExpr.op)
  return static_cast< ::milvus::proto::plan::BinaryArithOp >(op_);
}
inline void BinaryArithExpr::set_op(::milvus::proto::plan::BinaryArithOp value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryArithExpr.op)
}

// -------------------------------------------------------------------

// UnaryRangeExpr

// .milvus.proto.plan.Expr child = 1;
inline bool UnaryRangeExpr::has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline void UnaryRangeExpr::clear_child() {
  if (GetArenaNoVirtual() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& UnaryRangeExpr::child() const {
  const ::milvus::proto::plan::Expr* p = child_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryRangeExpr.child)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* UnaryRangeExpr::release_child() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.UnaryRangeExpr.child)
  
  ::milvus::proto::plan::Expr* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* UnaryRangeExpr::mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.UnaryRangeExpr.child)
  return child_;
}
inline void UnaryRangeExpr::set_allocated_child(::milvus::proto::plan::Expr* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.UnaryRangeExpr.child)
}

// .milvus.proto.plan.CompareOp op = 2;
inline void UnaryRangeExpr::clear_op() {
  op_ = 0;
}
inline ::milvus::proto::plan::CompareOp UnaryRangeExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryRangeExpr.op)
  return static_cast< ::milvus::proto::plan::CompareOp >(op_);
}
inline void UnaryRangeExpr::set_op(::milvus::proto::plan::CompareOp value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.UnaryRangeExpr.op)
}

// .milvus.proto.plan.GenericValue value = 3;
inline bool UnaryRangeExpr::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline void UnaryRangeExpr::clear_value() {
  if (GetArenaNoVirtual() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::milvus::proto::plan::GenericValue& UnaryRangeExpr::value() const {
  const ::milvus::proto::plan::GenericValue* p = value_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryRangeExpr.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::GenericValue*>(
      &::milvus::proto::plan::_GenericValue_default_instance_);
}
inline ::milvus::proto::plan::GenericValue* UnaryRangeExpr::release_value() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.UnaryRangeExpr.value)
  
  ::milvus::proto::plan::GenericValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* UnaryRangeExpr::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.UnaryRangeExpr.value)
  return value_;
}
inline void UnaryRangeExpr::set_allocated_value(::milvus::proto::plan::GenericValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.UnaryRangeExpr.value)
}

// -------------------------------------------------------------------

// BinaryRangeExpr

// .milvus.proto.plan.Expr child = 1;
inline bool BinaryRangeExpr::has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline void BinaryRangeExpr::clear_child() {
  if (GetArenaNoVirtual() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& BinaryRangeExpr::child() const {
  const ::milvus::proto::plan::Expr* p = child_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.child)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* BinaryRangeExpr::release_child() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryRangeExpr.child)
  
  ::milvus::proto::plan::Expr* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* BinaryRangeExpr::mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryRangeExpr.child)
  return child_;
}
inline void BinaryRangeExpr::set_allocated_child(::milvus::proto::plan::Expr* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryRangeExpr.child)
}

// bool lower_inclusive = 2;
inline void BinaryRangeExpr::clear_lower_inclusive() {
  lower_inclusive_ = false;
}
inline bool BinaryRangeExpr::lower_inclusive() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.lower_inclusive)
  return lower_inclusive_;
}
inline void BinaryRangeExpr::set_lower_inclusive(bool value) {
  
  lower_inclusive_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryRangeExpr.lower_inclusive)
}

// bool upper_inclusive = 3;
inline void BinaryRangeExpr::clear_upper_inclusive() {
  upper_inclusive_ = false;
}
inline bool BinaryRangeExpr::upper_inclusive() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.upper_inclusive)
  return upper_inclusive_;
}
inline void BinaryRangeExpr::set_upper_inclusive(bool value) {
  
  upper_inclusive_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryRangeExpr.upper_inclusive)
}

// .milvus.proto.plan.GenericValue lower_value = 4;
inline bool BinaryRangeExpr::has_lower_value() const {
  return this != internal_default_instance() && lower_value_ != nullptr;
}
inline void BinaryRangeExpr::clear_lower_value() {
  if (GetArenaNoVirtual() == nullptr && lower_value_ != nullptr) {
    delete lower_value_;
  }
  lower_value_ = nullptr;
}
inline const ::milvus::proto::plan::GenericValue& BinaryRangeExpr::lower_value() const {
  const ::milvus::proto::plan::GenericValue* p = lower_value_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.lower_value)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::GenericValue*>(
      &::milvus::proto::plan::_GenericValue_default_instance_);
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::release_lower_value() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryRangeExpr.lower_value)
  
  ::milvus::proto::plan::GenericValue* temp = lower_value_;
  lower_value_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::mutable_lower_value() {
  
  if (lower_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArenaNoVirtual());
    lower_value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryRangeExpr.lower_value)
  return lower_value_;
}
inline void BinaryRangeExpr::set_allocated_lower_value(::milvus::proto::plan::GenericValue* lower_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete lower_value_;
  }
  if (lower_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      lower_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lower_value, submessage_arena);
    }
    
  } else {
    
  }
  lower_value_ = lower_value;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryRangeExpr.lower_value)
}

// .milvus.proto.plan.GenericValue upper_value = 5;
inline bool BinaryRangeExpr::has_upper_value() const {
  return this != internal_default_instance() && upper_value_ != nullptr;
}
inline void BinaryRangeExpr::clear_upper_value() {
  if (GetArenaNoVirtual() == nullptr && upper_value_ != nullptr) {
    delete upper_value_;
  }
  upper_value_ = nullptr;
}
inline const ::milvus::proto::plan::GenericValue& BinaryRangeExpr::upper_value() const {
  const ::milvus::proto::plan::GenericValue* p = upper_value_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryRangeExpr.upper_value)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::GenericValue*>(
      &::milvus::proto::plan::_GenericValue_default_instance_);
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::release_upper_value() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryRangeExpr.upper_value)
  
  ::milvus::proto::plan::GenericValue* temp = upper_value_;
  upper_value_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::GenericValue* BinaryRangeExpr::mutable_upper_value() {
  
  if (upper_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::GenericValue>(GetArenaNoVirtual());
    upper_value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryRangeExpr.upper_value)
  return upper_value_;
}
inline void BinaryRangeExpr::set_allocated_upper_value(::milvus::proto::plan::GenericValue* upper_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete upper_value_;
  }
  if (upper_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      upper_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upper_value, submessage_arena);
    }
    
  } else {
    
  }
  upper_value_ = upper_value;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryRangeExpr.upper_value)
}

// -------------------------------------------------------------------

// CompareExpr

// .milvus.proto.plan.Expr left = 1;
inline bool CompareExpr::has_left() const {
  return this != internal_default_instance() && left_ != nullptr;
}
inline void CompareExpr::clear_left() {
  if (GetArenaNoVirtual() == nullptr && left_ != nullptr) {
    delete left_;
  }
  left_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& CompareExpr::left() const {
  const ::milvus::proto::plan::Expr* p = left_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.CompareExpr.left)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* CompareExpr::release_left() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.CompareExpr.left)
  
  ::milvus::proto::plan::Expr* temp = left_;
  left_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* CompareExpr::mutable_left() {
  
  if (left_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.CompareExpr.left)
  return left_;
}
inline void CompareExpr::set_allocated_left(::milvus::proto::plan::Expr* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete left_;
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.CompareExpr.left)
}

// .milvus.proto.plan.Expr right = 2;
inline bool CompareExpr::has_right() const {
  return this != internal_default_instance() && right_ != nullptr;
}
inline void CompareExpr::clear_right() {
  if (GetArenaNoVirtual() == nullptr && right_ != nullptr) {
    delete right_;
  }
  right_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& CompareExpr::right() const {
  const ::milvus::proto::plan::Expr* p = right_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.CompareExpr.right)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* CompareExpr::release_right() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.CompareExpr.right)
  
  ::milvus::proto::plan::Expr* temp = right_;
  right_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* CompareExpr::mutable_right() {
  
  if (right_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.CompareExpr.right)
  return right_;
}
inline void CompareExpr::set_allocated_right(::milvus::proto::plan::Expr* right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete right_;
  }
  if (right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.CompareExpr.right)
}

// .milvus.proto.plan.CompareOp op = 3;
inline void CompareExpr::clear_op() {
  op_ = 0;
}
inline ::milvus::proto::plan::CompareOp CompareExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.CompareExpr.op)
  return static_cast< ::milvus::proto::plan::CompareOp >(op_);
}
inline void CompareExpr::set_op(::milvus::proto::plan::CompareOp value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.CompareExpr.op)
}

// -------------------------------------------------------------------

// TermExpr

// .milvus.proto.plan.Expr child = 1;
inline bool TermExpr::has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline void TermExpr::clear_child() {
  if (GetArenaNoVirtual() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& TermExpr::child() const {
  const ::milvus::proto::plan::Expr* p = child_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.TermExpr.child)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* TermExpr::release_child() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.TermExpr.child)
  
  ::milvus::proto::plan::Expr* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* TermExpr::mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.TermExpr.child)
  return child_;
}
inline void TermExpr::set_allocated_child(::milvus::proto::plan::Expr* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.TermExpr.child)
}

// repeated .milvus.proto.plan.GenericValue values = 2;
inline int TermExpr::values_size() const {
  return values_.size();
}
inline void TermExpr::clear_values() {
  values_.Clear();
}
inline ::milvus::proto::plan::GenericValue* TermExpr::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.TermExpr.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::milvus::proto::plan::GenericValue >*
TermExpr::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.plan.TermExpr.values)
  return &values_;
}
inline const ::milvus::proto::plan::GenericValue& TermExpr::values(int index) const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.TermExpr.values)
  return values_.Get(index);
}
inline ::milvus::proto::plan::GenericValue* TermExpr::add_values() {
  // @@protoc_insertion_point(field_add:milvus.proto.plan.TermExpr.values)
  return values_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::milvus::proto::plan::GenericValue >&
TermExpr::values() const {
  // @@protoc_insertion_point(field_list:milvus.proto.plan.TermExpr.values)
  return values_;
}

// -------------------------------------------------------------------

// UnaryLogicalExpr

// .milvus.proto.plan.Expr child = 1;
inline bool UnaryLogicalExpr::has_child() const {
  return this != internal_default_instance() && child_ != nullptr;
}
inline void UnaryLogicalExpr::clear_child() {
  if (GetArenaNoVirtual() == nullptr && child_ != nullptr) {
    delete child_;
  }
  child_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& UnaryLogicalExpr::child() const {
  const ::milvus::proto::plan::Expr* p = child_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryLogicalExpr.child)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* UnaryLogicalExpr::release_child() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.UnaryLogicalExpr.child)
  
  ::milvus::proto::plan::Expr* temp = child_;
  child_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* UnaryLogicalExpr::mutable_child() {
  
  if (child_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.UnaryLogicalExpr.child)
  return child_;
}
inline void UnaryLogicalExpr::set_allocated_child(::milvus::proto::plan::Expr* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.UnaryLogicalExpr.child)
}

// .milvus.proto.plan.UnaryLogicalOp op = 2;
inline void UnaryLogicalExpr::clear_op() {
  op_ = 0;
}
inline ::milvus::proto::plan::UnaryLogicalOp UnaryLogicalExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.UnaryLogicalExpr.op)
  return static_cast< ::milvus::proto::plan::UnaryLogicalOp >(op_);
}
inline void UnaryLogicalExpr::set_op(::milvus::proto::plan::UnaryLogicalOp value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.UnaryLogicalExpr.op)
}

// -------------------------------------------------------------------

// BinaryLogicalExpr

// .milvus.proto.plan.Expr left = 1;
inline bool BinaryLogicalExpr::has_left() const {
  return this != internal_default_instance() && left_ != nullptr;
}
inline void BinaryLogicalExpr::clear_left() {
  if (GetArenaNoVirtual() == nullptr && left_ != nullptr) {
    delete left_;
  }
  left_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& BinaryLogicalExpr::left() const {
  const ::milvus::proto::plan::Expr* p = left_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryLogicalExpr.left)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* BinaryLogicalExpr::release_left() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryLogicalExpr.left)
  
  ::milvus::proto::plan::Expr* temp = left_;
  left_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* BinaryLogicalExpr::mutable_left() {
  
  if (left_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryLogicalExpr.left)
  return left_;
}
inline void BinaryLogicalExpr::set_allocated_left(::milvus::proto::plan::Expr* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete left_;
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryLogicalExpr.left)
}

// .milvus.proto.plan.Expr right = 2;
inline bool BinaryLogicalExpr::has_right() const {
  return this != internal_default_instance() && right_ != nullptr;
}
inline void BinaryLogicalExpr::clear_right() {
  if (GetArenaNoVirtual() == nullptr && right_ != nullptr) {
    delete right_;
  }
  right_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& BinaryLogicalExpr::right() const {
  const ::milvus::proto::plan::Expr* p = right_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryLogicalExpr.right)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* BinaryLogicalExpr::release_right() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.BinaryLogicalExpr.right)
  
  ::milvus::proto::plan::Expr* temp = right_;
  right_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* BinaryLogicalExpr::mutable_right() {
  
  if (right_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.BinaryLogicalExpr.right)
  return right_;
}
inline void BinaryLogicalExpr::set_allocated_right(::milvus::proto::plan::Expr* right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete right_;
  }
  if (right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.BinaryLogicalExpr.right)
}

// .milvus.proto.plan.BinaryLogicalOp op = 3;
inline void BinaryLogicalExpr::clear_op() {
  op_ = 0;
}
inline ::milvus::proto::plan::BinaryLogicalOp BinaryLogicalExpr::op() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.BinaryLogicalExpr.op)
  return static_cast< ::milvus::proto::plan::BinaryLogicalOp >(op_);
}
inline void BinaryLogicalExpr::set_op(::milvus::proto::plan::BinaryLogicalOp value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.BinaryLogicalExpr.op)
}

// -------------------------------------------------------------------

// Expr

// .milvus.proto.plan.TermExpr term_expr = 1;
inline bool Expr::has_term_expr() const {
  return expr_case() == kTermExpr;
}
inline void Expr::set_has_term_expr() {
  _oneof_case_[0] = kTermExpr;
}
inline void Expr::clear_term_expr() {
  if (has_term_expr()) {
    delete expr_.term_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::TermExpr* Expr::release_term_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.term_expr)
  if (has_term_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::TermExpr* temp = expr_.term_expr_;
    expr_.term_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::TermExpr& Expr::term_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.term_expr)
  return has_term_expr()
      ? *expr_.term_expr_
      : *reinterpret_cast< ::milvus::proto::plan::TermExpr*>(&::milvus::proto::plan::_TermExpr_default_instance_);
}
inline ::milvus::proto::plan::TermExpr* Expr::mutable_term_expr() {
  if (!has_term_expr()) {
    clear_expr();
    set_has_term_expr();
    expr_.term_expr_ = CreateMaybeMessage< ::milvus::proto::plan::TermExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.term_expr)
  return expr_.term_expr_;
}

// .milvus.proto.plan.CompareExpr compare_expr = 2;
inline bool Expr::has_compare_expr() const {
  return expr_case() == kCompareExpr;
}
inline void Expr::set_has_compare_expr() {
  _oneof_case_[0] = kCompareExpr;
}
inline void Expr::clear_compare_expr() {
  if (has_compare_expr()) {
    delete expr_.compare_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::CompareExpr* Expr::release_compare_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.compare_expr)
  if (has_compare_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::CompareExpr* temp = expr_.compare_expr_;
    expr_.compare_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::CompareExpr& Expr::compare_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.compare_expr)
  return has_compare_expr()
      ? *expr_.compare_expr_
      : *reinterpret_cast< ::milvus::proto::plan::CompareExpr*>(&::milvus::proto::plan::_CompareExpr_default_instance_);
}
inline ::milvus::proto::plan::CompareExpr* Expr::mutable_compare_expr() {
  if (!has_compare_expr()) {
    clear_expr();
    set_has_compare_expr();
    expr_.compare_expr_ = CreateMaybeMessage< ::milvus::proto::plan::CompareExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.compare_expr)
  return expr_.compare_expr_;
}

// .milvus.proto.plan.UnaryLogicalExpr unary_logical_expr = 3;
inline bool Expr::has_unary_logical_expr() const {
  return expr_case() == kUnaryLogicalExpr;
}
inline void Expr::set_has_unary_logical_expr() {
  _oneof_case_[0] = kUnaryLogicalExpr;
}
inline void Expr::clear_unary_logical_expr() {
  if (has_unary_logical_expr()) {
    delete expr_.unary_logical_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::UnaryLogicalExpr* Expr::release_unary_logical_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.unary_logical_expr)
  if (has_unary_logical_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::UnaryLogicalExpr* temp = expr_.unary_logical_expr_;
    expr_.unary_logical_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::UnaryLogicalExpr& Expr::unary_logical_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.unary_logical_expr)
  return has_unary_logical_expr()
      ? *expr_.unary_logical_expr_
      : *reinterpret_cast< ::milvus::proto::plan::UnaryLogicalExpr*>(&::milvus::proto::plan::_UnaryLogicalExpr_default_instance_);
}
inline ::milvus::proto::plan::UnaryLogicalExpr* Expr::mutable_unary_logical_expr() {
  if (!has_unary_logical_expr()) {
    clear_expr();
    set_has_unary_logical_expr();
    expr_.unary_logical_expr_ = CreateMaybeMessage< ::milvus::proto::plan::UnaryLogicalExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.unary_logical_expr)
  return expr_.unary_logical_expr_;
}

// .milvus.proto.plan.BinaryLogicalExpr binary_logical_expr = 4;
inline bool Expr::has_binary_logical_expr() const {
  return expr_case() == kBinaryLogicalExpr;
}
inline void Expr::set_has_binary_logical_expr() {
  _oneof_case_[0] = kBinaryLogicalExpr;
}
inline void Expr::clear_binary_logical_expr() {
  if (has_binary_logical_expr()) {
    delete expr_.binary_logical_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::BinaryLogicalExpr* Expr::release_binary_logical_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.binary_logical_expr)
  if (has_binary_logical_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::BinaryLogicalExpr* temp = expr_.binary_logical_expr_;
    expr_.binary_logical_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::BinaryLogicalExpr& Expr::binary_logical_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.binary_logical_expr)
  return has_binary_logical_expr()
      ? *expr_.binary_logical_expr_
      : *reinterpret_cast< ::milvus::proto::plan::BinaryLogicalExpr*>(&::milvus::proto::plan::_BinaryLogicalExpr_default_instance_);
}
inline ::milvus::proto::plan::BinaryLogicalExpr* Expr::mutable_binary_logical_expr() {
  if (!has_binary_logical_expr()) {
    clear_expr();
    set_has_binary_logical_expr();
    expr_.binary_logical_expr_ = CreateMaybeMessage< ::milvus::proto::plan::BinaryLogicalExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.binary_logical_expr)
  return expr_.binary_logical_expr_;
}

// .milvus.proto.plan.UnaryRangeExpr unary_range_expr = 5;
inline bool Expr::has_unary_range_expr() const {
  return expr_case() == kUnaryRangeExpr;
}
inline void Expr::set_has_unary_range_expr() {
  _oneof_case_[0] = kUnaryRangeExpr;
}
inline void Expr::clear_unary_range_expr() {
  if (has_unary_range_expr()) {
    delete expr_.unary_range_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::UnaryRangeExpr* Expr::release_unary_range_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.unary_range_expr)
  if (has_unary_range_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::UnaryRangeExpr* temp = expr_.unary_range_expr_;
    expr_.unary_range_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::UnaryRangeExpr& Expr::unary_range_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.unary_range_expr)
  return has_unary_range_expr()
      ? *expr_.unary_range_expr_
      : *reinterpret_cast< ::milvus::proto::plan::UnaryRangeExpr*>(&::milvus::proto::plan::_UnaryRangeExpr_default_instance_);
}
inline ::milvus::proto::plan::UnaryRangeExpr* Expr::mutable_unary_range_expr() {
  if (!has_unary_range_expr()) {
    clear_expr();
    set_has_unary_range_expr();
    expr_.unary_range_expr_ = CreateMaybeMessage< ::milvus::proto::plan::UnaryRangeExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.unary_range_expr)
  return expr_.unary_range_expr_;
}

// .milvus.proto.plan.BinaryRangeExpr binary_range_expr = 6;
inline bool Expr::has_binary_range_expr() const {
  return expr_case() == kBinaryRangeExpr;
}
inline void Expr::set_has_binary_range_expr() {
  _oneof_case_[0] = kBinaryRangeExpr;
}
inline void Expr::clear_binary_range_expr() {
  if (has_binary_range_expr()) {
    delete expr_.binary_range_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::BinaryRangeExpr* Expr::release_binary_range_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.binary_range_expr)
  if (has_binary_range_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::BinaryRangeExpr* temp = expr_.binary_range_expr_;
    expr_.binary_range_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::BinaryRangeExpr& Expr::binary_range_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.binary_range_expr)
  return has_binary_range_expr()
      ? *expr_.binary_range_expr_
      : *reinterpret_cast< ::milvus::proto::plan::BinaryRangeExpr*>(&::milvus::proto::plan::_BinaryRangeExpr_default_instance_);
}
inline ::milvus::proto::plan::BinaryRangeExpr* Expr::mutable_binary_range_expr() {
  if (!has_binary_range_expr()) {
    clear_expr();
    set_has_binary_range_expr();
    expr_.binary_range_expr_ = CreateMaybeMessage< ::milvus::proto::plan::BinaryRangeExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.binary_range_expr)
  return expr_.binary_range_expr_;
}

// .milvus.proto.plan.UnaryArithExpr unary_arith_expr = 7;
inline bool Expr::has_unary_arith_expr() const {
  return expr_case() == kUnaryArithExpr;
}
inline void Expr::set_has_unary_arith_expr() {
  _oneof_case_[0] = kUnaryArithExpr;
}
inline void Expr::clear_unary_arith_expr() {
  if (has_unary_arith_expr()) {
    delete expr_.unary_arith_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::UnaryArithExpr* Expr::release_unary_arith_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.unary_arith_expr)
  if (has_unary_arith_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::UnaryArithExpr* temp = expr_.unary_arith_expr_;
    expr_.unary_arith_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::UnaryArithExpr& Expr::unary_arith_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.unary_arith_expr)
  return has_unary_arith_expr()
      ? *expr_.unary_arith_expr_
      : *reinterpret_cast< ::milvus::proto::plan::UnaryArithExpr*>(&::milvus::proto::plan::_UnaryArithExpr_default_instance_);
}
inline ::milvus::proto::plan::UnaryArithExpr* Expr::mutable_unary_arith_expr() {
  if (!has_unary_arith_expr()) {
    clear_expr();
    set_has_unary_arith_expr();
    expr_.unary_arith_expr_ = CreateMaybeMessage< ::milvus::proto::plan::UnaryArithExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.unary_arith_expr)
  return expr_.unary_arith_expr_;
}

// .milvus.proto.plan.BinaryArithExpr binary_arith_expr = 8;
inline bool Expr::has_binary_arith_expr() const {
  return expr_case() == kBinaryArithExpr;
}
inline void Expr::set_has_binary_arith_expr() {
  _oneof_case_[0] = kBinaryArithExpr;
}
inline void Expr::clear_binary_arith_expr() {
  if (has_binary_arith_expr()) {
    delete expr_.binary_arith_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::BinaryArithExpr* Expr::release_binary_arith_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.binary_arith_expr)
  if (has_binary_arith_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::BinaryArithExpr* temp = expr_.binary_arith_expr_;
    expr_.binary_arith_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::BinaryArithExpr& Expr::binary_arith_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.binary_arith_expr)
  return has_binary_arith_expr()
      ? *expr_.binary_arith_expr_
      : *reinterpret_cast< ::milvus::proto::plan::BinaryArithExpr*>(&::milvus::proto::plan::_BinaryArithExpr_default_instance_);
}
inline ::milvus::proto::plan::BinaryArithExpr* Expr::mutable_binary_arith_expr() {
  if (!has_binary_arith_expr()) {
    clear_expr();
    set_has_binary_arith_expr();
    expr_.binary_arith_expr_ = CreateMaybeMessage< ::milvus::proto::plan::BinaryArithExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.binary_arith_expr)
  return expr_.binary_arith_expr_;
}

// .milvus.proto.plan.ValueExpr value_expr = 9;
inline bool Expr::has_value_expr() const {
  return expr_case() == kValueExpr;
}
inline void Expr::set_has_value_expr() {
  _oneof_case_[0] = kValueExpr;
}
inline void Expr::clear_value_expr() {
  if (has_value_expr()) {
    delete expr_.value_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::ValueExpr* Expr::release_value_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.value_expr)
  if (has_value_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::ValueExpr* temp = expr_.value_expr_;
    expr_.value_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::ValueExpr& Expr::value_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.value_expr)
  return has_value_expr()
      ? *expr_.value_expr_
      : *reinterpret_cast< ::milvus::proto::plan::ValueExpr*>(&::milvus::proto::plan::_ValueExpr_default_instance_);
}
inline ::milvus::proto::plan::ValueExpr* Expr::mutable_value_expr() {
  if (!has_value_expr()) {
    clear_expr();
    set_has_value_expr();
    expr_.value_expr_ = CreateMaybeMessage< ::milvus::proto::plan::ValueExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.value_expr)
  return expr_.value_expr_;
}

// .milvus.proto.plan.ColumnExpr column_expr = 10;
inline bool Expr::has_column_expr() const {
  return expr_case() == kColumnExpr;
}
inline void Expr::set_has_column_expr() {
  _oneof_case_[0] = kColumnExpr;
}
inline void Expr::clear_column_expr() {
  if (has_column_expr()) {
    delete expr_.column_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::ColumnExpr* Expr::release_column_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.column_expr)
  if (has_column_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::ColumnExpr* temp = expr_.column_expr_;
    expr_.column_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::ColumnExpr& Expr::column_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.column_expr)
  return has_column_expr()
      ? *expr_.column_expr_
      : *reinterpret_cast< ::milvus::proto::plan::ColumnExpr*>(&::milvus::proto::plan::_ColumnExpr_default_instance_);
}
inline ::milvus::proto::plan::ColumnExpr* Expr::mutable_column_expr() {
  if (!has_column_expr()) {
    clear_expr();
    set_has_column_expr();
    expr_.column_expr_ = CreateMaybeMessage< ::milvus::proto::plan::ColumnExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.column_expr)
  return expr_.column_expr_;
}

// .milvus.proto.plan.CastExpr cast_expr = 11;
inline bool Expr::has_cast_expr() const {
  return expr_case() == kCastExpr;
}
inline void Expr::set_has_cast_expr() {
  _oneof_case_[0] = kCastExpr;
}
inline void Expr::clear_cast_expr() {
  if (has_cast_expr()) {
    delete expr_.cast_expr_;
    clear_has_expr();
  }
}
inline ::milvus::proto::plan::CastExpr* Expr::release_cast_expr() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.Expr.cast_expr)
  if (has_cast_expr()) {
    clear_has_expr();
      ::milvus::proto::plan::CastExpr* temp = expr_.cast_expr_;
    expr_.cast_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::CastExpr& Expr::cast_expr() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.Expr.cast_expr)
  return has_cast_expr()
      ? *expr_.cast_expr_
      : *reinterpret_cast< ::milvus::proto::plan::CastExpr*>(&::milvus::proto::plan::_CastExpr_default_instance_);
}
inline ::milvus::proto::plan::CastExpr* Expr::mutable_cast_expr() {
  if (!has_cast_expr()) {
    clear_expr();
    set_has_cast_expr();
    expr_.cast_expr_ = CreateMaybeMessage< ::milvus::proto::plan::CastExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.Expr.cast_expr)
  return expr_.cast_expr_;
}

inline bool Expr::has_expr() const {
  return expr_case() != EXPR_NOT_SET;
}
inline void Expr::clear_has_expr() {
  _oneof_case_[0] = EXPR_NOT_SET;
}
inline Expr::ExprCase Expr::expr_case() const {
  return Expr::ExprCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// VectorANNS

// bool is_binary = 1;
inline void VectorANNS::clear_is_binary() {
  is_binary_ = false;
}
inline bool VectorANNS::is_binary() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.is_binary)
  return is_binary_;
}
inline void VectorANNS::set_is_binary(bool value) {
  
  is_binary_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.VectorANNS.is_binary)
}

// int64 field_id = 2;
inline void VectorANNS::clear_field_id() {
  field_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VectorANNS::field_id() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.field_id)
  return field_id_;
}
inline void VectorANNS::set_field_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  field_id_ = value;
  // @@protoc_insertion_point(field_set:milvus.proto.plan.VectorANNS.field_id)
}

// .milvus.proto.plan.Expr predicates = 3;
inline bool VectorANNS::has_predicates() const {
  return this != internal_default_instance() && predicates_ != nullptr;
}
inline void VectorANNS::clear_predicates() {
  if (GetArenaNoVirtual() == nullptr && predicates_ != nullptr) {
    delete predicates_;
  }
  predicates_ = nullptr;
}
inline const ::milvus::proto::plan::Expr& VectorANNS::predicates() const {
  const ::milvus::proto::plan::Expr* p = predicates_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.predicates)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::Expr*>(
      &::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* VectorANNS::release_predicates() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.VectorANNS.predicates)
  
  ::milvus::proto::plan::Expr* temp = predicates_;
  predicates_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::Expr* VectorANNS::mutable_predicates() {
  
  if (predicates_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::Expr>(GetArenaNoVirtual());
    predicates_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.VectorANNS.predicates)
  return predicates_;
}
inline void VectorANNS::set_allocated_predicates(::milvus::proto::plan::Expr* predicates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete predicates_;
  }
  if (predicates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      predicates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, predicates, submessage_arena);
    }
    
  } else {
    
  }
  predicates_ = predicates;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.VectorANNS.predicates)
}

// .milvus.proto.plan.QueryInfo query_info = 4;
inline bool VectorANNS::has_query_info() const {
  return this != internal_default_instance() && query_info_ != nullptr;
}
inline void VectorANNS::clear_query_info() {
  if (GetArenaNoVirtual() == nullptr && query_info_ != nullptr) {
    delete query_info_;
  }
  query_info_ = nullptr;
}
inline const ::milvus::proto::plan::QueryInfo& VectorANNS::query_info() const {
  const ::milvus::proto::plan::QueryInfo* p = query_info_;
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.query_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::milvus::proto::plan::QueryInfo*>(
      &::milvus::proto::plan::_QueryInfo_default_instance_);
}
inline ::milvus::proto::plan::QueryInfo* VectorANNS::release_query_info() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.VectorANNS.query_info)
  
  ::milvus::proto::plan::QueryInfo* temp = query_info_;
  query_info_ = nullptr;
  return temp;
}
inline ::milvus::proto::plan::QueryInfo* VectorANNS::mutable_query_info() {
  
  if (query_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::milvus::proto::plan::QueryInfo>(GetArenaNoVirtual());
    query_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.VectorANNS.query_info)
  return query_info_;
}
inline void VectorANNS::set_allocated_query_info(::milvus::proto::plan::QueryInfo* query_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete query_info_;
  }
  if (query_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      query_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_info, submessage_arena);
    }
    
  } else {
    
  }
  query_info_ = query_info;
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.VectorANNS.query_info)
}

// string placeholder_tag = 5;
inline void VectorANNS::clear_placeholder_tag() {
  placeholder_tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VectorANNS::placeholder_tag() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.VectorANNS.placeholder_tag)
  return placeholder_tag_.GetNoArena();
}
inline void VectorANNS::set_placeholder_tag(const std::string& value) {
  
  placeholder_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.VectorANNS.placeholder_tag)
}
inline void VectorANNS::set_placeholder_tag(std::string&& value) {
  
  placeholder_tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:milvus.proto.plan.VectorANNS.placeholder_tag)
}
inline void VectorANNS::set_placeholder_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  placeholder_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:milvus.proto.plan.VectorANNS.placeholder_tag)
}
inline void VectorANNS::set_placeholder_tag(const char* value, size_t size) {
  
  placeholder_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:milvus.proto.plan.VectorANNS.placeholder_tag)
}
inline std::string* VectorANNS::mutable_placeholder_tag() {
  
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.VectorANNS.placeholder_tag)
  return placeholder_tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VectorANNS::release_placeholder_tag() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.VectorANNS.placeholder_tag)
  
  return placeholder_tag_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VectorANNS::set_allocated_placeholder_tag(std::string* placeholder_tag) {
  if (placeholder_tag != nullptr) {
    
  } else {
    
  }
  placeholder_tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), placeholder_tag);
  // @@protoc_insertion_point(field_set_allocated:milvus.proto.plan.VectorANNS.placeholder_tag)
}

// -------------------------------------------------------------------

// PlanNode

// .milvus.proto.plan.VectorANNS vector_anns = 1;
inline bool PlanNode::has_vector_anns() const {
  return node_case() == kVectorAnns;
}
inline void PlanNode::set_has_vector_anns() {
  _oneof_case_[0] = kVectorAnns;
}
inline void PlanNode::clear_vector_anns() {
  if (has_vector_anns()) {
    delete node_.vector_anns_;
    clear_has_node();
  }
}
inline ::milvus::proto::plan::VectorANNS* PlanNode::release_vector_anns() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.PlanNode.vector_anns)
  if (has_vector_anns()) {
    clear_has_node();
      ::milvus::proto::plan::VectorANNS* temp = node_.vector_anns_;
    node_.vector_anns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::VectorANNS& PlanNode::vector_anns() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.PlanNode.vector_anns)
  return has_vector_anns()
      ? *node_.vector_anns_
      : *reinterpret_cast< ::milvus::proto::plan::VectorANNS*>(&::milvus::proto::plan::_VectorANNS_default_instance_);
}
inline ::milvus::proto::plan::VectorANNS* PlanNode::mutable_vector_anns() {
  if (!has_vector_anns()) {
    clear_node();
    set_has_vector_anns();
    node_.vector_anns_ = CreateMaybeMessage< ::milvus::proto::plan::VectorANNS >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.PlanNode.vector_anns)
  return node_.vector_anns_;
}

// .milvus.proto.plan.Expr predicates = 2;
inline bool PlanNode::has_predicates() const {
  return node_case() == kPredicates;
}
inline void PlanNode::set_has_predicates() {
  _oneof_case_[0] = kPredicates;
}
inline void PlanNode::clear_predicates() {
  if (has_predicates()) {
    delete node_.predicates_;
    clear_has_node();
  }
}
inline ::milvus::proto::plan::Expr* PlanNode::release_predicates() {
  // @@protoc_insertion_point(field_release:milvus.proto.plan.PlanNode.predicates)
  if (has_predicates()) {
    clear_has_node();
      ::milvus::proto::plan::Expr* temp = node_.predicates_;
    node_.predicates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::milvus::proto::plan::Expr& PlanNode::predicates() const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.PlanNode.predicates)
  return has_predicates()
      ? *node_.predicates_
      : *reinterpret_cast< ::milvus::proto::plan::Expr*>(&::milvus::proto::plan::_Expr_default_instance_);
}
inline ::milvus::proto::plan::Expr* PlanNode::mutable_predicates() {
  if (!has_predicates()) {
    clear_node();
    set_has_predicates();
    node_.predicates_ = CreateMaybeMessage< ::milvus::proto::plan::Expr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:milvus.proto.plan.PlanNode.predicates)
  return node_.predicates_;
}

// repeated int64 output_field_ids = 3;
inline int PlanNode::output_field_ids_size() const {
  return output_field_ids_.size();
}
inline void PlanNode::clear_output_field_ids() {
  output_field_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlanNode::output_field_ids(int index) const {
  // @@protoc_insertion_point(field_get:milvus.proto.plan.PlanNode.output_field_ids)
  return output_field_ids_.Get(index);
}
inline void PlanNode::set_output_field_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  output_field_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:milvus.proto.plan.PlanNode.output_field_ids)
}
inline void PlanNode::add_output_field_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  output_field_ids_.Add(value);
  // @@protoc_insertion_point(field_add:milvus.proto.plan.PlanNode.output_field_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
PlanNode::output_field_ids() const {
  // @@protoc_insertion_point(field_list:milvus.proto.plan.PlanNode.output_field_ids)
  return output_field_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
PlanNode::mutable_output_field_ids() {
  // @@protoc_insertion_point(field_mutable_list:milvus.proto.plan.PlanNode.output_field_ids)
  return &output_field_ids_;
}

inline bool PlanNode::has_node() const {
  return node_case() != NODE_NOT_SET;
}
inline void PlanNode::clear_has_node() {
  _oneof_case_[0] = NODE_NOT_SET;
}
inline PlanNode::NodeCase PlanNode::node_case() const {
  return PlanNode::NodeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace plan
}  // namespace proto
}  // namespace milvus

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::milvus::proto::plan::UnaryLogicalOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::milvus::proto::plan::UnaryLogicalOp>() {
  return ::milvus::proto::plan::UnaryLogicalOp_descriptor();
}
template <> struct is_proto_enum< ::milvus::proto::plan::BinaryLogicalOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::milvus::proto::plan::BinaryLogicalOp>() {
  return ::milvus::proto::plan::BinaryLogicalOp_descriptor();
}
template <> struct is_proto_enum< ::milvus::proto::plan::CompareOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::milvus::proto::plan::CompareOp>() {
  return ::milvus::proto::plan::CompareOp_descriptor();
}
template <> struct is_proto_enum< ::milvus::proto::plan::UnaryArithOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::milvus::proto::plan::UnaryArithOp>() {
  return ::milvus::proto::plan::UnaryArithOp_descriptor();
}
template <> struct is_proto_enum< ::milvus::proto::plan::BinaryArithOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::milvus::proto::plan::BinaryArithOp>() {
  return ::milvus::proto::plan::BinaryArithOp_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_plan_2eproto
